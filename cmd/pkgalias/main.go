package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	"go.chrisrx.dev/x/ptr"
	"go.chrisrx.dev/x/set"
	"go.chrisrx.dev/x/slices"
	"golang.org/x/tools/go/packages"
)

func main() {
	var (
		pkg    string
		ignore string
		out    string
		stdout bool
	)
	flag.StringVar(&pkg, "package", "", "The package path to alias")
	flag.StringVar(&ignore, "ignore", "", "A comma-delimited list of identifiers to ignore")
	flag.StringVar(&out, "out", "", "Directory to output alias.go file")
	flag.BoolVar(&stdout, "stdout", false, "Output to stdout")
	flag.Parse()

	if pkg == "" {
		v, ok := os.LookupEnv("GOPACKAGE")
		if !ok {
			log.Fatal("must provide package")
		}
		pkg = v
	}

	if out == "" {
		_, ok := os.LookupEnv("GOFILE")
		if !ok && !stdout {
			log.Fatal("must provide output directory or stdout")
		}
		dir, err := os.Getwd()
		if err != nil {
			log.Fatal(err)
		}
		out = filepath.Join(dir, "alias.go")
	}

	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadSyntax}, pkg)
	if err != nil {
		log.Fatal(err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	if len(pkgs) == 0 {
		log.Fatal("no packages")
	}
	file := parseFile(pkgs[0].Syntax, strings.Split(ignore, ",")...)
	data, err := GenerateFile(file)
	if err != nil {
		log.Fatal(err)
	}

	if stdout {
		fmt.Printf("%s\n", data)
		return
	}
	if err := os.WriteFile(out, data, 0644); err != nil {
		log.Fatal(err)
	}
}

var t = template.Must(template.New("").Funcs(map[string]any{
	"join":   join,
	"fields": (&printer{}).fieldList,
	"fieldnames": func(fields []*ast.Field) []string {
		return slices.FlatMap(fields, func(field *ast.Field) []string {
			names := slices.Map(field.Names, func(ident *ast.Ident) string {
				return ident.String()
			})
			if _, ok := field.Type.(*ast.Ellipsis); ok {
				return slices.Map(names, func(name string) string {
					return name + "..."
				})
			}
			return names
		})
	},
}).Parse(`// Code generated by pkgalias. DO NOT EDIT.
// This is an alias of package {{ .Name }}.

{{ .Docs | join "\n" }}
package {{ .Name }}

{{ with .Imports -}}
import (
  {{- range . }}
    "{{ . -}}"
  {{- end }}
)
{{- end }}

{{- range .Vars }}
{{ .Docs | join "\n" }}
var {{ .Name }} = {{ $.Name }}.{{ .Name }}
{{ end -}}

{{- range .Aliases }}
{{ .Docs | join "\n" }}
type {{ .Name }} = {{ $.Name }}.{{ .Name }}
{{ end -}}

{{ range .Funcs }}
{{ .Docs | join "\n" }}
func {{ .Name }}{{ with .TypeParams }}[{{ . | fields | join ", " }}]{{ end }}(
	{{- with .Params }}{{ . | fields | join ", " }}{{ end -}}
) (
	{{- with .Results }}{{ . | fields | join ", " }}{{ end -}}
) {
	{{ with .Results }}{{ if .List }}return {{ end }}{{ end}}{{ $.Name }}.{{ .Name }}(
		{{- with .Params }}
			{{- .List | fieldnames | join ", " -}}
		{{- end -}}
	)
}
{{ end -}}
`))

func join(sep string, v any) string {
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Array, reflect.Slice:
		var s []string
		for i := range rv.Len() {
			fv := rv.Index(i)
			s = append(s, str(fv.Interface()))
		}
		return strings.Join(s, sep)
	default:
		return fmt.Sprint(v)
	}
}

func str(v any) string {
	switch v := v.(type) {
	case string:
		return v
	case []byte:
		return string(v)
	case fmt.Stringer:
		return v.String()
	default:
		return fmt.Sprintf("%v", v)
	}
}

func GenerateFile(file *File) ([]byte, error) {
	var buf bytes.Buffer
	if err := t.Execute(&buf, file); err != nil {
		return nil, err
	}
	return format.Source(buf.Bytes())
}

type File struct {
	Name    string
	Docs    []string
	Imports []string
	Aliases []*Alias
	Funcs   []*Func
	Vars    []*Var
}

type Var struct {
	Name string
	Docs []string
}

type Func struct {
	Name       string
	Docs       []string
	TypeParams *ast.FieldList
	Params     *ast.FieldList
	Results    *ast.FieldList
}

type Alias struct {
	Name string
	Docs []string
}

func parseFile(files []*ast.File, ignore ...string) *File {
	if len(files) == 0 {
		return nil
	}

	file := &File{
		Name: files[0].Name.String(),
		Docs: slices.FlatMap(files, func(f *ast.File) []string {
			return slices.Map(ptr.From(f.Doc).List, func(c *ast.Comment) string {
				return c.Text
			})
		}),
		Imports: []string{files[0].Name.String()},
	}
	var printer printer
	printer.imports.Add(file.Name)
	for _, f := range files {
		for _, d := range f.Decls {
			switch d := d.(type) {
			case *ast.GenDecl:
				for _, spec := range d.Specs {
					switch t := spec.(type) {
					case *ast.TypeSpec:
						if !t.Name.IsExported() || slices.Contains(ignore, t.Name.String()) {
							continue
						}
						// printer.expr(t.Type)
						file.Aliases = append(file.Aliases, &Alias{
							Name: t.Name.String(),
							Docs: slices.Map(ptr.From(d.Doc).List, func(c *ast.Comment) string {
								return c.Text
							}),
						})
					case *ast.ValueSpec:
						for _, name := range t.Names {
							if name.IsExported() || slices.Contains(ignore, name.String()) {
								file.Vars = append(file.Vars, &Var{
									Name: name.String(),
									Docs: slices.Map(ptr.From(t.Doc).List, func(c *ast.Comment) string {
										return c.Text
									}),
								})
							}
						}
					}
				}
			case *ast.FuncDecl:
				if !d.Name.IsExported() || slices.Contains(ignore, d.Name.String()) {
					continue
				}
				if d.Recv != nil {
					continue
				}
				printer.fieldList(d.Type.TypeParams)
				printer.fieldList(d.Type.Params)
				printer.fieldList(d.Type.Results)
				for _, field := range ptr.From(d.Type.Params).List {
					for i, name := range field.Names {
						if name.String() == file.Name {
							field.Names[i].Name = name.String() + "_"
						}
					}
				}

				file.Funcs = append(file.Funcs, &Func{
					Name: d.Name.String(),
					Docs: slices.Map(ptr.From(d.Doc).List, func(c *ast.Comment) string {
						return c.Text
					}),
					TypeParams: d.Type.TypeParams,
					Params:     d.Type.Params,
					Results:    d.Type.Results,
				})
			}
		}
	}
	file.Imports = printer.imports.List()
	return file
}

type printer struct {
	imports set.Set[string]
}

func (p *printer) expr(x ast.Expr) string {
	switch t := x.(type) {
	case *ast.StarExpr:
		return fmt.Sprintf("*%s", p.expr(t.X))
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		p.imports.Add(p.expr(t.X))
		return fmt.Sprintf("%s.%s", p.expr(t.X), t.Sel.Name)
	case *ast.ArrayType:
		return fmt.Sprintf("[]%s", p.expr(t.Elt))
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", p.expr(t.Key), p.expr(t.Value))
	case *ast.Ellipsis:
		return fmt.Sprintf("...%s", p.expr(t.Elt))
	case *ast.IndexExpr:
		return fmt.Sprintf("%s[%s]", p.expr(t.X), t.Index)
	case *ast.IndexListExpr:
		indices := strings.Join(slices.Map(t.Indices, p.expr), ", ")
		return fmt.Sprintf("%s[%s]", p.expr(t.X), indices)
	case *ast.FuncType:
		var sb strings.Builder
		sb.WriteString("func(")
		sb.WriteString(strings.Join(p.fieldList(t.Params), ", "))
		sb.WriteString(") ")
		sb.WriteString("(")
		sb.WriteString(strings.Join(p.fieldList(t.Results), ", "))
		sb.WriteString(")")
		return sb.String()
	case *ast.UnaryExpr:
		return p.expr(t.X)
	case *ast.StructType:
		p.fieldList(t.Fields)
		return "idk"
	default:
		panic(fmt.Errorf("tt:  %T", t))
	}
}

func (p *printer) fieldList(fields *ast.FieldList) []string {
	if fields == nil {
		return nil
	}
	return slices.Map(fields.List, func(field *ast.Field) string {
		if len(field.Names) == 0 {
			return p.expr(field.Type)
		}
		return fmt.Sprintf("%s %s", strings.Join(
			slices.Map(field.Names, func(ident *ast.Ident) string {
				return ident.String()
			}), ", ",
		), p.expr(field.Type))
	})
}
