package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	"go.chrisrx.dev/x/ptr"
	"go.chrisrx.dev/x/set"
	"go.chrisrx.dev/x/slices"
	"golang.org/x/tools/go/packages"
	goimports "golang.org/x/tools/imports"

	"go.chrisrx.dev/tools/internal/ast"
)

func main() {
	var (
		pkg    string
		ignore string
		out    string
		stdout bool
	)
	flag.StringVar(&pkg, "package", "", "The package path to alias")
	flag.StringVar(&ignore, "ignore", "", "A comma-delimited list of identifiers to ignore")
	flag.StringVar(&out, "out", "", "Directory to output alias.go file")
	flag.BoolVar(&stdout, "stdout", false, "Output to stdout")
	flag.Parse()

	if pkg == "" {
		v, ok := os.LookupEnv("GOPACKAGE")
		if !ok {
			log.Fatal("must provide package")
		}
		pkg = v
	}

	if out == "" {
		_, ok := os.LookupEnv("GOFILE")
		if !ok && !stdout {
			log.Fatal("must provide output directory or stdout")
		}
		dir, err := os.Getwd()
		if err != nil {
			log.Fatal(err)
		}
		out = filepath.Join(dir, "alias.go")
	}

	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadAllSyntax}, pkg)
	if err != nil {
		log.Fatal(err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	if len(pkgs) == 0 {
		log.Fatal("no packages")
	}
	file := ParsePackage(pkgs[0], strings.Split(ignore, ",")...)
	data, err := GenerateFile(file)
	if err != nil {
		log.Fatal(err)
	}

	if stdout {
		fmt.Printf("%s\n", data)
		return
	}
	if err := os.WriteFile(out, data, 0644); err != nil {
		log.Fatal(err)
	}
}

var t = template.Must(template.New("").Funcs(map[string]any{
	"join":   join,
	"fields": (&ast.Printer{}).PrintFieldList,
	"fieldnames": func(fields []*ast.Field) []string {
		return slices.FlatMap(fields, func(field *ast.Field) []string {
			names := slices.Map(field.Names, func(ident *ast.Ident) string {
				return ident.String()
			})
			if _, ok := field.Type.(*ast.Ellipsis); ok {
				return slices.Map(names, func(name string) string {
					return name + "..."
				})
			}
			for i, name := range names {
				if name == "_" {
					// need zero value
					if ident, ok := field.Type.(*ast.Ident); ok {
						if ident.Name == "string" {
							names[i] = `""`
						}
					}
				}
			}
			return names
		})
	},
}).Parse(`// Code generated by aliaspkg. DO NOT EDIT.

{{ .Docs | join "\n" }}
package {{ .Name }}

{{ with .Imports -}}
import (
  {{- range . }}
    "{{ . -}}"
  {{- end }}
)
{{- end }}

{{- range .Consts }}
{{ with .Docs }}
{{ . | join "\n" }}
//
{{- end }}
// This is an alias of https://pkg.go.dev/{{ $.PkgPath }}#{{ .Name }}.
const {{ .Name }} = {{ $.Name }}.{{ .Name }}
{{ end -}}

{{- range .Vars }}
{{ with .Docs }}
{{ . | join "\n" }}
//
{{- end }}
// This is an alias of https://pkg.go.dev/{{ $.PkgPath }}#{{ .Name }}.
var {{ .Name }} = {{ $.Name }}.{{ .Name }}
{{ end -}}

{{- range .Aliases }}
{{ with .Docs }}
{{ . | join "\n" }}
//
{{- end }}
// This is an alias of https://pkg.go.dev/{{ $.PkgPath }}#{{ .Name }}.
type {{ .Name }} = {{ $.Name }}.{{ .Name }}
{{ end -}}

{{ range .Funcs }}
{{ with .Docs }}
{{ . | join "\n" }}
//
{{- end }}
// This is an alias of https://pkg.go.dev/{{ $.PkgPath }}#{{ .Name }}.
func {{ .Name }}{{ with .TypeParams }}[{{ . | fields | join ", " }}]{{ end }}(
	{{- with .Params }}{{ . | fields | join ", " }}{{ end -}}
) (
	{{- with .Results }}{{ . | fields | join ", " }}{{ end -}}
) {
	{{ with .Results }}{{ if .List }}return {{ end }}{{ end}}{{ $.Name }}.{{ .Name }}(
		{{- with .Params }}
			{{- .List | fieldnames | join ", " -}}
		{{- end -}}
	)
}
{{ end -}}
`))

func join(sep string, v any) string {
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Array, reflect.Slice:
		var s []string
		for i := range rv.Len() {
			fv := rv.Index(i)
			s = append(s, str(fv.Interface()))
		}
		return strings.Join(s, sep)
	default:
		return fmt.Sprint(v)
	}
}

func str(v any) string {
	switch v := v.(type) {
	case string:
		return v
	case []byte:
		return string(v)
	case fmt.Stringer:
		return v.String()
	default:
		return fmt.Sprintf("%v", v)
	}
}

func GenerateFile(file *File) ([]byte, error) {
	var buf bytes.Buffer
	if err := t.Execute(&buf, file); err != nil {
		return nil, err
	}
	return goimports.Process("", buf.Bytes(), &goimports.Options{
		TabIndent: true,
		AllErrors: true,
		Fragment:  true,
		Comments:  true,
	})
}

type File struct {
	Name    string
	PkgPath string
	Docs    []string
	Imports []string
	Aliases []*Alias
	Funcs   []*Func
	Consts  []*Const
	Vars    []*Var
}

type Const struct {
	Name string
	Docs []string
}

type Var struct {
	Name string
	Docs []string
}

type Func struct {
	Name       string
	Docs       []string
	TypeParams *ast.FieldList
	Params     *ast.FieldList
	Results    *ast.FieldList
}

type Alias struct {
	Name string
	Docs []string
}

func ParsePackage(pkg *packages.Package, ignore ...string) *File {
	file := parseFile(pkg.Syntax, ignore...)
	file.PkgPath = pkg.PkgPath

	imports := set.New(file.Imports...)
	for _, pkg := range pkg.Imports {
		if strings.Contains(pkg.PkgPath, "internal/") {
			continue
		}
		imports.Add(pkg.PkgPath)
	}
	imports.Add(pkg.PkgPath)
	file.Imports = imports.List()
	return file
}

func parseFile(files []*ast.File, ignore ...string) *File {
	if len(files) == 0 {
		return nil
	}

	file := &File{
		Name: files[0].Name.String(),
		Docs: slices.FlatMap(files, func(f *ast.File) []string {
			return slices.Map(ptr.From(f.Doc).List, func(c *ast.Comment) string {
				return c.Text
			})
		}),
	}
	for _, f := range files {
		for _, d := range f.Decls {
			switch d := d.(type) {
			case *ast.GenDecl:
				for _, spec := range d.Specs {
					switch t := spec.(type) {
					case *ast.TypeSpec:
						if !t.Name.IsExported() || slices.Contains(ignore, t.Name.String()) {
							continue
						}
						file.Aliases = append(file.Aliases, &Alias{
							Name: t.Name.String(),
							Docs: slices.Map(ptr.From(d.Doc).List, func(c *ast.Comment) string {
								return c.Text
							}),
						})
					case *ast.ValueSpec:
						for _, name := range t.Names {
							if name.IsExported() || slices.Contains(ignore, name.String()) {
								switch name.Obj.Kind {
								case ast.Con:
									file.Consts = append(file.Consts, &Const{
										Name: name.String(),
										Docs: slices.Map(ptr.From(t.Doc).List, func(c *ast.Comment) string {
											return c.Text
										}),
									})
								case ast.Var:
									file.Vars = append(file.Vars, &Var{
										Name: name.String(),
										Docs: slices.Map(ptr.From(t.Doc).List, func(c *ast.Comment) string {
											return c.Text
										}),
									})
								}
							}
						}
					}
				}
			case *ast.FuncDecl:
				if !d.Name.IsExported() || slices.Contains(ignore, d.Name.String()) {
					continue
				}
				if d.Recv != nil {
					continue
				}

				// Add a trailor to the field name if the parameter overlaps with an
				// import. Currently just looks at the package being aliased.
				for _, field := range ptr.From(d.Type.Params).List {
					for i, name := range field.Names {
						if name.String() == file.Name {
							field.Names[i].Name = name.String() + "_"
						}
					}
				}

				file.Funcs = append(file.Funcs, &Func{
					Name: d.Name.String(),
					Docs: slices.Map(ptr.From(d.Doc).List, func(c *ast.Comment) string {
						return c.Text
					}),
					TypeParams: d.Type.TypeParams,
					Params:     d.Type.Params,
					Results:    d.Type.Results,
				})
			}
		}
	}
	return file
}
